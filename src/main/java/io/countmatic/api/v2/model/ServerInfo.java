/*
 * countmatic api
 * countmatic is a service to provide counters as web service. Sure, counters are simple artefacts of IT systems. But they are part of *every* system. There are numerous use cases where you need distributed enumerators in IoT manufacturing or i.e. production reporting.    Find out more [https://countmatic.io](https://countmatic.io).
 *
 * OpenAPI spec version: 2.0.2
 * Contact: countmaster@countmatic.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.countmatic.api.v2.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;

/**
 * some server information
 */
@ApiModel(description = "some server information")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-02-13T08:49:11.883+01:00")
public class ServerInfo {
  @SerializedName("server")
  private String server = null;

  @SerializedName("persistentBackend")
  private String persistentBackend = null;

  @SerializedName("volatileBackend")
  private String volatileBackend = null;

  @SerializedName("apiVersion")
  private String apiVersion = null;

  @SerializedName("maxNamesPerToken")
  private Long maxNamesPerToken = null;

  @SerializedName("capacityLoad")
  private Integer capacityLoad = null;

  @SerializedName("runtimeLoad")
  private Integer runtimeLoad = null;

  @SerializedName("currentCounters")
  private Long currentCounters = null;

  @SerializedName("maxCounters")
  private Long maxCounters = null;

  public ServerInfo server(String server) {
    this.server = server;
    return this;
  }

   /**
   * the server software running at the backend
   * @return server
  **/
  @ApiModelProperty(value = "the server software running at the backend")
  public String getServer() {
    return server;
  }

  public void setServer(String server) {
    this.server = server;
  }

  public ServerInfo persistentBackend(String persistentBackend) {
    this.persistentBackend = persistentBackend;
    return this;
  }

   /**
   * the software used for persistent data
   * @return persistentBackend
  **/
  @ApiModelProperty(value = "the software used for persistent data")
  public String getPersistentBackend() {
    return persistentBackend;
  }

  public void setPersistentBackend(String persistentBackend) {
    this.persistentBackend = persistentBackend;
  }

  public ServerInfo volatileBackend(String volatileBackend) {
    this.volatileBackend = volatileBackend;
    return this;
  }

   /**
   * the software used to keep volatile data
   * @return volatileBackend
  **/
  @ApiModelProperty(value = "the software used to keep volatile data")
  public String getVolatileBackend() {
    return volatileBackend;
  }

  public void setVolatileBackend(String volatileBackend) {
    this.volatileBackend = volatileBackend;
  }

  public ServerInfo apiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
    return this;
  }

   /**
   * the countmatic API version of this server
   * @return apiVersion
  **/
  @ApiModelProperty(value = "the countmatic API version of this server")
  public String getApiVersion() {
    return apiVersion;
  }

  public void setApiVersion(String apiVersion) {
    this.apiVersion = apiVersion;
  }

  public ServerInfo maxNamesPerToken(Long maxNamesPerToken) {
    this.maxNamesPerToken = maxNamesPerToken;
    return this;
  }

   /**
   * maximum number of counters in a grouptoken
   * @return maxNamesPerToken
  **/
  @ApiModelProperty(value = "maximum number of counters in a grouptoken")
  public Long getMaxNamesPerToken() {
    return maxNamesPerToken;
  }

  public void setMaxNamesPerToken(Long maxNamesPerToken) {
    this.maxNamesPerToken = maxNamesPerToken;
  }

  public ServerInfo capacityLoad(Integer capacityLoad) {
    this.capacityLoad = capacityLoad;
    return this;
  }

   /**
   * capacity load of the server at a scale of 0-100
   * @return capacityLoad
  **/
  @ApiModelProperty(value = "capacity load of the server at a scale of 0-100")
  public Integer getCapacityLoad() {
    return capacityLoad;
  }

  public void setCapacityLoad(Integer capacityLoad) {
    this.capacityLoad = capacityLoad;
  }

  public ServerInfo runtimeLoad(Integer runtimeLoad) {
    this.runtimeLoad = runtimeLoad;
    return this;
  }

   /**
   * performance load of the server at a scale of 0-100
   * @return runtimeLoad
  **/
  @ApiModelProperty(value = "performance load of the server at a scale of 0-100")
  public Integer getRuntimeLoad() {
    return runtimeLoad;
  }

  public void setRuntimeLoad(Integer runtimeLoad) {
    this.runtimeLoad = runtimeLoad;
  }

  public ServerInfo currentCounters(Long currentCounters) {
    this.currentCounters = currentCounters;
    return this;
  }

   /**
   * number of active counters in that server
   * @return currentCounters
  **/
  @ApiModelProperty(value = "number of active counters in that server")
  public Long getCurrentCounters() {
    return currentCounters;
  }

  public void setCurrentCounters(Long currentCounters) {
    this.currentCounters = currentCounters;
  }

  public ServerInfo maxCounters(Long maxCounters) {
    this.maxCounters = maxCounters;
    return this;
  }

   /**
   * limit of active counters that server can manage (or 0 for unlimited)
   * @return maxCounters
  **/
  @ApiModelProperty(value = "limit of active counters that server can manage (or 0 for unlimited)")
  public Long getMaxCounters() {
    return maxCounters;
  }

  public void setMaxCounters(Long maxCounters) {
    this.maxCounters = maxCounters;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ServerInfo serverInfo = (ServerInfo) o;
    return Objects.equals(this.server, serverInfo.server) &&
        Objects.equals(this.persistentBackend, serverInfo.persistentBackend) &&
        Objects.equals(this.volatileBackend, serverInfo.volatileBackend) &&
        Objects.equals(this.apiVersion, serverInfo.apiVersion) &&
        Objects.equals(this.maxNamesPerToken, serverInfo.maxNamesPerToken) &&
        Objects.equals(this.capacityLoad, serverInfo.capacityLoad) &&
        Objects.equals(this.runtimeLoad, serverInfo.runtimeLoad) &&
        Objects.equals(this.currentCounters, serverInfo.currentCounters) &&
        Objects.equals(this.maxCounters, serverInfo.maxCounters);
  }

  @Override
  public int hashCode() {
    return Objects.hash(server, persistentBackend, volatileBackend, apiVersion, maxNamesPerToken, capacityLoad, runtimeLoad, currentCounters, maxCounters);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ServerInfo {\n");
    
    sb.append("    server: ").append(toIndentedString(server)).append("\n");
    sb.append("    persistentBackend: ").append(toIndentedString(persistentBackend)).append("\n");
    sb.append("    volatileBackend: ").append(toIndentedString(volatileBackend)).append("\n");
    sb.append("    apiVersion: ").append(toIndentedString(apiVersion)).append("\n");
    sb.append("    maxNamesPerToken: ").append(toIndentedString(maxNamesPerToken)).append("\n");
    sb.append("    capacityLoad: ").append(toIndentedString(capacityLoad)).append("\n");
    sb.append("    runtimeLoad: ").append(toIndentedString(runtimeLoad)).append("\n");
    sb.append("    currentCounters: ").append(toIndentedString(currentCounters)).append("\n");
    sb.append("    maxCounters: ").append(toIndentedString(maxCounters)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
  
}

